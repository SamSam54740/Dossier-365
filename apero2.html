<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>LE FOY'S - PLOMBERIE</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #050505;
            --neon-blue: #00f3ff;
            --neon-alert: #ff0055;
            --beer-gold: #ffcc00;
            --pipe-dark: #222;
            --pipe-width: 8px; 
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }

        body {
            font-family: 'Orbitron', sans-serif;
            background-color: var(--bg-color);
            color: white;
            margin: 0; padding: 0;
            height: 100vh; width: 100vw;
            /* Layout vertical strict pour mobile */
            display: flex; flex-direction: column; 
            overflow: hidden;
        }

        /* 1. HEADER (Compact) */
        #top-ui {
            flex-shrink: 0; /* Ne r√©tr√©cit pas */
            width: 100%; padding: 10px; text-align: center;
            background: #111; border-bottom: 2px solid #333;
            z-index: 10;
        }
        
        h1 { margin: 0; font-size: 1rem; color: var(--beer-gold); letter-spacing: 2px; }
        .subtitle { font-size: 0.7rem; color: #888; margin-bottom: 5px; }

        #pressure-container {
            width: 100%; height: 15px; background: #222;
            border: 1px solid #555; border-radius: 10px;
            position: relative; overflow: hidden;
        }
        
        #pressure-bar {
            width: 0%; height: 100%; background: linear-gradient(90deg, #00ff00, #ffff00, #ff0000);
            transition: width 0.2s linear;
        }

        /* 2. BOARD (Prend tout l'espace restant) */
        #game-board {
            flex-grow: 1; /* Prend l'espace libre */
            width: 100%; 
            display: flex; align-items: center; justify-content: center;
            position: relative; 
            padding: 10px; /* Marge de s√©curit√© */
        }

        #grid-container {
            position: relative;
            width: 95vw; /* Max largeur mobile */
            height: 95vw; /* Carr√© */
            max-height: 65vh; /* Ne pas d√©passer la hauteur dispo */
            max-width: 65vh;  /* Garder le carr√© */
        }

        #grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(10, 1fr);
            gap: 0; 
            background: #000;
            border: 2px solid #444;
            width: 100%; height: 100%;
        }

        /* MARQUEURS (Coll√©s √† la grille) */
        .marker {
            position: absolute; 
            font-size: 0.8rem; font-weight: bold; 
            color: var(--beer-gold); 
            background: #111; border: 1px solid #333; padding: 2px 5px; border-radius: 4px;
            z-index: 20; pointer-events: none;
            display: flex; align-items: center; gap: 5px;
            white-space: nowrap;
        }
        #start-marker { 
            top: -25px; left: 0; 
        }
        #end-marker { 
            bottom: -25px; right: 0; 
        }

        /* TUILES & TUYAUX */
        .tile {
            width: 100%; height: 100%;
            position: relative; cursor: pointer;
            background: #151515; border: 0.5px solid #222;
            transition: transform 0.1s linear; 
        }
        
        .arm { position: absolute; background: var(--pipe-dark); transition: background 0.2s; }
        .center-hub {
            position: absolute; top: 50%; left: 50%;
            width: var(--pipe-width); height: var(--pipe-width);
            background: var(--pipe-dark);
            transform: translate(-50%, -50%); border-radius: 50%;
            transition: background 0.2s;
        }
        .arm.top { top: 0; left: 50%; width: var(--pipe-width); height: 50%; transform: translateX(-50%); }
        .arm.bottom { bottom: 0; left: 50%; width: var(--pipe-width); height: 50%; transform: translateX(-50%); }
        .arm.left { left: 0; top: 50%; width: 50%; height: var(--pipe-width); transform: translateY(-50%); }
        .arm.right { right: 0; top: 50%; width: 50%; height: var(--pipe-width); transform: translateY(-50%); }

        /* ETATS LIQUIDE */
        .tile.filled .arm, .tile.filled .center-hub { background: var(--beer-gold); box-shadow: 0 0 5px var(--beer-gold); }
        .tile.error .arm, .tile.error .center-hub { background: var(--neon-alert); box-shadow: 0 0 5px red; }

        /* 3. FOOTER (Bouton accessible) */
        #controls {
            flex-shrink: 0;
            width: 100%; padding: 15px;
            display: flex; justify-content: center; align-items: center;
            background: #111; border-top: 1px solid #333;
        }
        #btn-check {
            width: 100%; max-width: 300px;
            padding: 15px 0; border-radius: 50px; border: none;
            background: var(--beer-gold); color: black;
            font-weight: 900; font-size: 1.1rem; cursor: pointer;
            box-shadow: 0 0 15px rgba(255, 204, 0, 0.4);
            animation: pulse 1.5s infinite;
            text-transform: uppercase;
        }

        /* OVERLAYS */
        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.98); z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            text-align: center; padding: 20px;
        }
        .hidden { display: none; }
        
        #explode-overlay { background: rgba(255, 170, 0, 0.95); color: black; }
        
        .shake { animation: shake 0.5s infinite; }
        @keyframes shake { 0% { transform: translate(1px, 1px); } 50% { transform: translate(-1px, -2px); } 100% { transform: translate(1px, -2px); } }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.02); } 100% { transform: scale(1); } }

    </style>
</head>
<body>

    <div id="top-ui">
        <h1>LE FOY'S BAR</h1>
        <div class="subtitle">MISSION : LES PILIERS</div>
        <div id="pressure-container">
            <div id="pressure-bar"></div>
        </div>
    </div>

    <div id="game-board">
        <div id="grid-container">
            <div class="marker" id="start-marker">üõ¢Ô∏è COMME D'HAB</div>
            
            <div id="grid">
                </div>

            <div class="marker" id="end-marker">TIREUSE FOY'S üç∫</div>
        </div>
    </div>

    <div id="controls">
        <button id="btn-check" onclick="checkWin()">OUVRIR LA VANNE</button>
    </div>

    <div id="intro-overlay" class="overlay">
        <h1 style="color:var(--beer-gold); font-size:2.5rem;">√âTAPE 2</h1>
        <p style="font-size:1rem; color:#ccc;">CONNECTE LA "COMME D'HAB"</p>
        <div style="background:#222; padding:15px; margin:20px; border:1px solid #444; text-align:left; font-size:0.9rem;">
            <p>1. Les Piliers ont soif.</p>
            <p>2. Connecte le <b>F√ªt</b> (Haut) √† la <b>Tireuse</b> (Bas).</p>
            <p>3. Attention : La pression monte <b>VITE</b>.</p>
            <p style="color:red; text-align:center; font-weight:bold;">FUITE = P√âNALIT√â !</p>
        </div>
        <button id="btn-check" onclick="startLevel()">JE G√àRE</button>
    </div>

    <div id="explode-overlay" class="overlay hidden">
        <h1 style="font-size:4rem; margin:0;">BOUM !</h1>
        <p style="font-size:1.5rem; font-weight:bold;">QUEL G√ÇCHIS...</p>
        <div style="border:4px solid black; padding:20px; font-weight:bold; margin-top:20px; transform:rotate(-2deg); font-size:1.5rem; background:white;">
            P√âNALIT√â : 3 GORG√âES
        </div>
        <button style="margin-top:30px; padding:15px; background:black; color:white; border:none; font-weight:bold; cursor:pointer;" onclick="retryLevel()">J'AI BU, JE R√âESSAYE</button>
    </div>

    <div id="win-overlay" class="overlay hidden">
        <h1 style="color:var(--neon-blue); font-size:3rem;">SANT√â !</h1>
        <p>Service impeccable.</p>
        <button id="btn-check" onclick="nextStep()">√âTAPE 3</button>
    </div>

    <script>
        const ROWS = 10;
        const COLS = 10;
        const NB_TILES = 100;

        const TILES_DEF = {
            'I': [1, 0, 1, 0], 
            'L': [1, 1, 0, 0]
        };

        let tiles = []; 
        let pressure = 0;
        let gameInterval;
        let isPlaying = false;
        let isChecking = false; // Bloque le jeu pendant l'animation

        function startLevel() {
            document.getElementById('intro-overlay').classList.add('hidden');
            generateLevel();
            pressure = 0;
            isPlaying = true;
            gameInterval = setInterval(gameLoop, 100); // 100ms
        }

        // --- GENERATEUR SPAGHETTI (Chemin unique + leurres) ---
        function generateLevel() {
            const grid = document.getElementById('grid');
            grid.innerHTML = '';
            tiles = new Array(NB_TILES).fill(null);

            // 1. Snake Path
            let visited = new Set();
            createSnakePath(0, 99, visited);
            
            // 2. Decoyst
            fillWithDecoys(visited);

            // 3. Render
            for(let i=0; i<NB_TILES; i++) {
                const data = tiles[i];
                const el = document.createElement('div');
                el.className = 'tile';
                el.id = `tile-${i}`;
                
                const startRot = Math.floor(Math.random() * 4) * 90;
                createVisuals(el, data.type);
                
                el.style.transform = `rotate(${startRot}deg)`;
                el.onclick = () => rotateTile(i);
                
                grid.appendChild(el);
                
                tiles[i].el = el;
                tiles[i].visualRot = startRot;
                tiles[i].baseConn = TILES_DEF[data.type];
            }
        }

        function createSnakePath(start, end, visited) {
            let success = false;
            while(!success) {
                visited.clear();
                let path = [start];
                visited.add(start);
                let curr = start;
                let stuck = false;

                while(curr !== end && !stuck) {
                    let neighbors = getNeighbors(curr);
                    let validNeighbors = neighbors.filter(n => !visited.has(n));
                    
                    if(validNeighbors.length > 0) {
                        validNeighbors.sort((a,b) => dist(a, end) - dist(b, end) + (Math.random()*10 - 5));
                        let next = validNeighbors[0];
                        if(Math.random() > 0.6 && validNeighbors.length > 1) next = validNeighbors[1];

                        visited.add(next);
                        path.push(next);
                        curr = next;
                    } else {
                        stuck = true;
                    }
                }

                if(curr === end && path.length > 25) { // Min 25 cases pour que ce soit long
                    success = true;
                    for(let i=0; i<path.length; i++) {
                        let c = path[i];
                        let p = (i===0) ? (c-10) : path[i-1];
                        let n = (i===path.length-1) ? (c+10) : path[i+1];
                        
                        let d1 = getDir(c, p);
                        let d2 = getDir(c, n);
                        let type = (Math.abs(d1 - d2) === 2) ? 'I' : 'L';
                        tiles[c] = { type: type };
                    }
                }
            }
        }

        function fillWithDecoys(visitedMain) {
            for(let i=0; i<NB_TILES; i++) {
                if(!visitedMain.has(i)) {
                    tiles[i] = { type: (Math.random() > 0.5 ? 'I' : 'L') };
                }
            }
        }

        function getNeighbors(idx) {
            let n = [];
            let r = Math.floor(idx/10), c = idx%10;
            if(r>0) n.push(idx-10);
            if(c<9) n.push(idx+1);
            if(r<9) n.push(idx+10);
            if(c>0) n.push(idx-1);
            return n;
        }

        function dist(a, b) {
            let r1 = Math.floor(a/10), c1 = a%10;
            let r2 = Math.floor(b/10), c2 = b%10;
            return Math.abs(r1-r2) + Math.abs(c1-c2);
        }

        function getDir(from, to) {
            if(to === from - 10) return 0;
            if(to === from + 1) return 1;
            if(to === from + 10) return 2;
            if(to === from - 1) return 3;
            return -1;
        }

        function createVisuals(el, type) {
            el.innerHTML += '<div class="center-hub"></div>';
            const conns = TILES_DEF[type];
            if(conns[0]) el.innerHTML += '<div class="arm top"></div>';
            if(conns[1]) el.innerHTML += '<div class="arm right"></div>';
            if(conns[2]) el.innerHTML += '<div class="arm bottom"></div>';
            if(conns[3]) el.innerHTML += '<div class="arm left"></div>';
        }

        function rotateTile(idx) {
            if(!isPlaying || isChecking) return;
            const t = tiles[idx];
            t.visualRot += 90; 
            t.el.style.transform = `rotate(${t.visualRot}deg)`;
            document.querySelectorAll('.tile').forEach(e => e.classList.remove('filled', 'error'));
        }

        function gameLoop() {
            if(!isPlaying) return;
            // Difficult√© : Pression monte de 0.25% toutes les 100ms
            pressure += 0.25; 
            
            document.getElementById('pressure-bar').style.width = Math.min(pressure, 100) + "%";
            
            if(pressure > 85) {
                document.body.classList.add('shake');
                document.getElementById('pressure-bar').style.background = "red";
            }
            if(pressure >= 100) explode();
        }

        function explode() {
            isPlaying = false;
            clearInterval(gameInterval);
            document.body.classList.remove('shake');
            document.getElementById('explode-overlay').classList.remove('hidden');
        }

        function retryLevel() {
            document.getElementById('explode-overlay').classList.add('hidden');
            document.body.classList.remove('shake');
            document.getElementById('pressure-bar').style.background = "linear-gradient(90deg, #00ff00, #ffff00, #ff0000)";
            startLevel();
        }

        // --- ANIMATION DE FLUX ---
        async function checkWin() {
            if(!isPlaying || isChecking) return;
            isChecking = true; // Bloque les clics
            
            // Calculer le chemin
            const pathData = calculateFlow();
            const flowPath = pathData.path;
            const success = pathData.success;

            // Animation du flux
            for (let i = 0; i < flowPath.length; i++) {
                tiles[flowPath[i]].el.classList.add('filled');
                // Petit d√©lai pour l'effet liquide
                await new Promise(r => setTimeout(r, 50)); 
            }

            // R√©sultat
            if(success) {
                isPlaying = false;
                clearInterval(gameInterval);
                document.body.classList.remove('shake');
                setTimeout(() => document.getElementById('win-overlay').classList.remove('hidden'), 500);
            } else {
                // Erreur
                if(flowPath.length > 0) tiles[flowPath[flowPath.length-1]].el.classList.add('error');
                else tiles[0].el.classList.add('error');
                
                pressure += 25; // Grosse p√©nalit√©
                document.getElementById('pressure-container').classList.add('shake');
                setTimeout(() => document.getElementById('pressure-container').classList.remove('shake'), 500);
                
                await new Promise(r => setTimeout(r, 1000));
                document.querySelectorAll('.tile').forEach(e => e.classList.remove('filled', 'error'));
                isChecking = false; // D√©bloque
            }
        }

        function calculateFlow() {
            const visited = new Set();
            let flowPath = [];
            let success = false;
            
            // Stack pour flood recursif (mais on le fait iteratif pour simplifier l'enregistrement du chemin unique)
            // Ici on suit le flux. Si bifurcation, on prend le premier valide.
            // Vu que c'est des tuyaux simples, il n'y a qu'une sortie max par entr√©e.
            
            let curr = 0;
            let from = 0; // Entr√©e HAUT
            let flowing = true;

            while(flowing) {
                if(visited.has(curr)) break; // Boucle
                
                const t = tiles[curr];
                const logicRot = t.visualRot % 360;
                const realConns = getRealConnections(t.type, logicRot);
                
                if(!realConns[from]) { flowing = false; break; } // Bloqu√© √† l'entr√©e

                visited.add(curr);
                flowPath.push(curr);

                if(curr === 99 && (realConns[2] || realConns[1])) {
                    success = true;
                    flowing = false;
                    break;
                }

                // Trouver la sortie
                let next = -1;
                let nextFrom = -1;

                // Haut
                if(realConns[0] && from !== 0 && curr >= 10) { next = curr - 10; nextFrom = 2; }
                // Droite
                else if(realConns[1] && from !== 1 && curr % 10 !== 9) { next = curr + 1; nextFrom = 3; }
                // Bas
                else if(realConns[2] && from !== 2 && curr < 90) { next = curr + 10; nextFrom = 0; }
                // Gauche
                else if(realConns[3] && from !== 3 && curr % 10 !== 0) { next = curr - 1; nextFrom = 1; }

                if(next !== -1) {
                    curr = next;
                    from = nextFrom;
                } else {
                    flowing = false; // Cul de sac
                }
            }
            return { path: flowPath, success: success };
        }

        function getRealConnections(type, rot) {
            const shift = rot / 90;
            const base = TILES_DEF[type];
            let res = [0,0,0,0];
            for(let i=0; i<4; i++) {
                if(base[i]) res[(i + shift)%4] = 1;
            }
            return res;
        }

        function nextStep() {
            window.location.href = "apero3.html";
        }

    </script>
</body>
</html>